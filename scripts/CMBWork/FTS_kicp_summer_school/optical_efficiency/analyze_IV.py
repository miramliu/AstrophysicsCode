# analyze_IV.py
#
# A Python module which contains tools for analyzing IV data from the
# 'drop_bolos' algorithm in pydfmux. The primary functionality is to estimate
# Psat values and G from IV curves at several temperatures. The two functions
# that interact directly with pydfmux data which are most likely to be useful
# to the end user are:
# 1.) find_Psat : find the Psat from the output of drop_bolos
# 2.) find_G_params : fits Psat data as a function of temperature to extract
#         parameters k, n, G, Tc
#
# Adam Anderson
# adama@fnal.gov
# 7 January 2015

import cPickle as pickle
import numpy as np
from scipy.optimize import curve_fit
import matplotlib.pyplot as plt
import os


def find_Psat(pkl_file, R_threshold=0.95, plot_dir=None, interp=True, Zp=[]):
    '''
    Function to find TES Psat values from IV data acquired from 'drop_bolos'.
    The algorithm used here is fairly dumb but simple, and it should be fairly
    robust. We simply find Rn from the R(P) data of the IV curve, then we
    interpolate to find the value of P at which the resistance crosses the
    fraction of Rn specified in R_threshold (95% of Rn by default).

    NB: The current and voltage logs saved by the 'drop_bolos' algorithm are
    normalized to the AMPLITUDE of the carrier (not peak-to-peak or RMS). In
    this statement I am following the convention that:
        AMPLITUDE = (1/2) * (peak-to-peak amplitude) = sqrt(2) * RMS
    This difference is significant because the relevant power used to compute
    the saturation power is the RMS power, not the power amplitude, i.e.
        P_RMS = I_RMS**2 / R
    This is NOT the power that is plotted in the summary plots generated by
    'drop_bolos'.

    Parameters
    ----------
    pkl_file : string
        Full path to a pickle file with the output from 'drop_bolos'
    R_threshold (default=0.95) : float or 'pturn':
        Fraction of Rn at which to call the bolometer saturated. If set to
        'pturn', Psat is calculated at turn-around in the I-V curve.
    plot_dir (default=None) : string
        Directory in which to save plots; setting equal to None produces no
        plots
    interp (default=True) : bool
        Flag to interpolate to find R_threshold. If false, we just pick the
        nearest data point with a resistance above R_threshold.
    Zp : dict
        Total parasitic impedance (as measured from IV curves, for example),
        used to calculate a corrected normal resistance
        {readout channel # -> Psat value} (e.g. from 'find_Z')

    Returns
    -------
    Psat : python dictionary
        {readout channel # -> Psat value}
    '''
    IV_file = file(pkl_file, 'r')
    IV_data = pickle.load(IV_file)
    IV_file.close()

    Lp = 0.
    Psat_data = dict()

    chanlist = [chan for chan in IV_data['RIV_log']]
    for channel in chanlist:
        boloname = IV_data['subtargets'][channel]['physical_name']
        V = np.array(IV_data['RIV_log'][channel]['V'])
        V = V[np.where(V!=0)[0]]
        I = np.array(IV_data['RIV_log'][channel]['I'])
        I = I[np.where(V!=0)[0]]
        Z = np.array(IV_data['RIV_log'][channel]['R'])
        Z = Z[np.where(V!=0)[0]]
        f = IV_data['current'][channel]['freq']
        #if Zp == [] or not any([boloname in chan for chan in Zp.keys()]):
        #    Zp_chan = 0.0
        #else:
        #    Zp_chan = [Zp[chan] for chan in Zp.keys() if boloname in chan][0]
        if Zp ==[] or boloname not in Zp.keys():
          Zp_chan=0
        else:
          Zp_chan=Zp[boloname]
        R_TES = np.sqrt(np.maximum(Z**2. - (2.*np.pi*f * Lp)**2., np.zeros(len(Z)))) - \
                np.sqrt(np.maximum(Zp_chan**2. - (2.*np.pi*f * Lp)**2., np.zeros(len(Z))))
        P_TES = (I / np.sqrt(2.))**2. * R_TES

        pturn,hasPturn=findpturn(I,V,P_TES)
        
        if hasPturn:
            if R_threshold=='pturn':
                Psat = pturn
            else:
                # find the first resistance (from left) below 0.95*Rn, taking Rn
                # to be the average of the 10 resistances
                Rn_above_Pturn = R_TES[P_TES > pturn][-10:]
                Rn = np.mean(Rn_above_Pturn)
                Rn_std = np.std(Rn_above_Pturn)
                Psbelow = P_TES[R_TES < R_threshold*Rn]
                if len(Psbelow[Psbelow<pturn]) > 0 and \
                   np.abs(Rn_std / Rn) < 0.05:
                    Pbelow=max(Psbelow[Psbelow<pturn])
                    if Pbelow > 0:
                        if interp == True:
                            Psat = np.interp(R_threshold*Rn, R_TES[P_TES >= Pbelow], P_TES[P_TES >= Pbelow])
                        else:
                            Psat = np.min(P_TES[R_TES>R_threshold*Rn])
                    else:
                        Psat = np.nan
                else:
                    Psat = np.nan
        else:
            Psat = np.nan
        #if Zp_chan==0:
        #    Psat = np.nan
        #print Zp_chan
        Psat_data[channel] = {'P': P_TES, 'R': R_TES, 'Psat': Psat}
        Psat_return = {channel: Psat_data[channel]['Psat'] for channel in Psat_data.keys()}

    if plot_dir != None:
        fig = plot_Psat(Psat_data)
        filename = pkl_file.split('/')[-1]
        fig.savefig(plot_dir + '/' + filename.strip('.pkl') + '_PsatofT.png')

    return Psat_return


def plot_Psat(Psat_data):
    '''
    Plot P(R) with Psat indicated on plot. Mainly useful for checking
    validity of Psat. Pretty trivial.

    Parameters
    ----------
    Psat_data : python dictionary
        {channel # -> {'P': array of power,
                       'R': array of resistance,
                       'Psat': Psat value}}

    Returns
    -------
    fig : handle to figure
    '''
    ncols = np.ceil(np.sqrt(len(Psat_data)))
    nrows = np.ceil(len(Psat_data) / ncols)

    fig = plt.figure()
    for jchannel, channel in enumerate(Psat_data):
        R = Psat_data[channel]['R']
        P = Psat_data[channel]['P']
        Psat = Psat_data[channel]['Psat']

        plt.subplot(nrows, ncols, jchannel+1)
        plt.plot(P, R, linestyle='None', marker='o', color='b')
        plt.plot([Psat, Psat], [np.min(R), np.max(R)], linestyle='--', color='r')
        plt.grid(True)

    return fig


def find_Z(pkl_file, fit_range, chans_to_fit=[], plot_path=None):
    '''
    Find the impedance from the IV curves.

    Parameters
    ----------
    pkl_file : str
        Full path to pickle file produced by drop_bolos algorithm.
    fit_range : int, 2-tuple, or arr_like of 2-tuples
        If 2-tuple (V1, V2), then fits data between voltages V1 and V2.
        If dict of 2-tuples {channum -> (V1, V2)}, then fits data between
        voltages V1 and V2 on channel channum.
    chans_to_fit (default=[]) : array-like
        List of channels for which to fit Z. If [] then all channels are fit.
    plot_path (default=None) : str
        Full path to plot.

    Returns
    -------
    Zp : dict
        {readout channel # -> Psat value}
    '''
    f = file(pkl_file)
    data = pickle.load(f)
    f.close()

    def f_fit(x, R): return x / R

    Z = dict()
    bolonames = dict()
    for channum in data['RIV_log'].keys():
        boloname = data['subtargets'][channum]['bolometer']
        bolonames[channum] = boloname

        # select data to fit
        if channum in chans_to_fit or len(chans_to_fit)==0:
            if type(fit_range) == int:
                c_select = np.arange(len(data['RIV_log'][channum]['V'])-11,
                                     len(data['RIV_log'][channum]['V'])-1)
            elif type(fit_range) == tuple:
                c_select = np.logical_and(np.array(data['RIV_log'][channum]['V']) > fit_range[0],
                                          np.array(data['RIV_log'][channum]['V']) < fit_range[1])
            elif type(fit_range) == list:
                c_select = np.logical_and(np.array(data['RIV_log'][channum]['V']) > fit_range[channum][0],
                                          np.array(data['RIV_log'][channum]['V']) < fit_range[channum][1])
            V_data = np.array(data['RIV_log'][channum]['V'])[c_select]
            I_data = np.array(data['RIV_log'][channum]['I'])[c_select]
            popt, pcov = curve_fit(f_fit, V_data, I_data)
            # fit_params = np.polyfit(I_data, V_data, deg=1)
            Z[boloname] = popt[0]

    if plot_path != None:
        ncols = np.ceil(np.sqrt(len(data['RIV_log'])))
        nrows = np.ceil(len(data['RIV_log']) / ncols)

        f = plt.figure(figsize=(ncols*2., nrows*2.))
        for jchan, channum in enumerate(data['RIV_log'].keys()):
            plt.subplot(nrows, ncols, jchan+1)
            V_data = 1e6 * np.array(data['RIV_log'][channum]['V'])
            I_data = 1e6 * np.array(data['RIV_log'][channum]['I'])
            plt.plot(V_data, I_data, 'bo', markersize=1)
            if channum in chans_to_fit or len(chans_to_fit)==0:
                minV = 1e6*np.min(data['RIV_log'][channum]['V'])
                maxV = 1e6*np.max(data['RIV_log'][channum]['V'])
                plotV = np.linspace(minV, maxV)
                plt.plot(plotV, plotV / Z[bolonames[channum]], 'r--', linewidth=1)
        big_ax = f.add_subplot(111)
        big_ax.set_axis_bgcolor('none')
        big_ax.spines['top'].set_color('none')
        big_ax.spines['bottom'].set_color('none')
        big_ax.spines['left'].set_color('none')
        big_ax.spines['right'].set_color('none')
        big_ax.tick_params(labelcolor='w', top='off', bottom='off', left='off', right='off')
        big_ax.set_xlabel('voltage (amplitude) [uV]')
        big_ax.set_ylabel('current (amplitude) [uA]')

        f.savefig(plot_path)

    return Z


def plot_IV(pkl_file, plot_dir):
    '''
    Plots the IV curves from the drop_bolos algorithm.

    Parameters
    ----------
    pkl_file : string
        full path to pickle file produced by drop_bolos algorithm

    Returns
    -------
    fig : figure handle
    '''
    f = file(pkl_file)
    data = pickle.load(f)
    f.close()

    fig = plt.figure()
    for channum in data['RIV_log'].keys():
        plt.plot(1.e6*np.array(data['RIV_log'][channum]['V']),
                 1.e6*np.array(data['RIV_log'][channum]['I']), label=str(channum))
    plt.xlabel('V_bias (amplitude) [uV]')
    plt.ylabel('I_TES (amplitude) [uA]')
    plt.legend(loc='upper left')
    plt.savefig(plot_dir + '/' + pkl_file.strip('.pkl') + '.png')

    return fig
    
def findpturn(i,v,p):
    '''
    Figures out if there is a turn-around in IV data.
    
    Parameters
    ----------
    i: array of current values
    v: array of voltage values
    p: array of power values
    
    Returns
    -------
    2-tuple (pturn, hasPturn)
        The power at turn-around (float), and if turn-around exists (bool)
    '''
    di = i[1:]-i[:-1]
    dv = v[1:]-v[:-1]
    
    # Suppress RuntimeWarnings about dividing by zero
    zero_ind=np.where(dv==0)[0]
    dv[zero_ind]=np.inf
    
    didv = di/dv
    signprod=didv[1:]*didv[:-1]
    idxpturn = np.where(signprod <= 0)[0]
    if len(idxpturn > 0):
       pturn = p[np.where(i==min(i[idxpturn]))][0]
       hasPTurn = True
    else:
       pturn = np.nan
       hasPTurn = False
    return pturn, hasPTurn
